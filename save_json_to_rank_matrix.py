"""Script to convert json data into a ranking matrix and save."""

import os
import json
from datetime import datetime

import yaml
from absl import app
from absl import flags
from typing import Any, Optional

import numpy as np
import pandas as pd

flags.DEFINE_string(
    "config_file_path",
    "./configs/data_config.yaml",
    "Path to the config file for generating ranking data.",
)

FLAGS = flags.FLAGS


def _increment_ranking_matrix(
        matrix,
        object_set_1: dict[str, Any],
        object_set_2: Optional[dict[str, Any]],
        column_id: int,
    ):
    """Add a rearrangement scene cluster to the ranking matrix.
    
    This script generates separate ranking matrices for positive and negative
    object pairs. If only object_set_1 is provided, all object combinations from
    this set are positive pairs, else object combinations across object sets are
    negative pairs. 

    Args:
        matrix: Ranking matrix to update.
        object_set_1: First group of objects in the scene.
        object_set_2: Second group of objects in the scene. Defaults to None if
            we are updating the positive matrix.
        column_id: Column ID to update. This depends on the schema corresponding
            to the scene.
    """
    global objcomb2row

    if object_set_2 is None:
        for index, obj_1 in enumerate(object_set_1):
            for obj_2 in object_set_1[index+1:]:
                row_id = objcomb2row(obj_1, obj_2)
                matrix[row_id, column_id] = 1

    else:
        for obj_1 in object_set_1:
            for obj_2 in object_set_2:
                row_id = objcomb2row(obj_1, obj_2)
                matrix[row_id, column_id] = 0


def generate_ranking_matrix(json_examples, object_combinations, rules_list):
    """Generate a pairwise ranking matrix from the json data.
    
    The pairwise ranking matrix is generated by combining separate count
    matrices for positive and negative object pairs.
    
    Args:
        json_examples: JSON data of goal scenes.
        object_combinations: TODO.
        rules_list: List of schemas in the dataset.
    """

    global rules2col

    positive_ranking_matrix = np.zeros((len(object_combinations), len(rules_list)))
    negative_ranking_matrix = np.zeros((len(object_combinations), len(rules_list)))

    for scene in json_examples.values():

        rule = scene['rule']
        goal_scene = scene['goal']['scene']

        container_ids = [key for key in goal_scene.keys() if key != 'table']

        rule_column_id = rules2col(rule)

        for cid in container_ids:
            _increment_ranking_matrix(
                positive_ranking_matrix, 
                object_set_1=goal_scene[cid],
                object_set_2=None,
                column_id=rule_column_id
            )

        for i, cid_1 in enumerate(container_ids):
            for cid_2 in container_ids[i+1:]:
                _increment_ranking_matrix(
                    negative_ranking_matrix,
                    object_set_1=goal_scene[cid_1], 
                    object_set_2=goal_scene[cid_2],
                    column_id=rule_column_id
                )

    # -1 means the rating does not exist
    final_ranking_matrix = -1*np.ones((len(object_combinations), len(rules_list)))

    number_noratings = 0
    number_conflicting = 0
    for row in range(len(object_combinations)):
        for col in range(len(rules_list)):

            # if either the rating does not exist (both 0) or there are conflicting rating (both 1)
            if negative_ranking_matrix[row, col] == positive_ranking_matrix[row, col] == 1:
                final_ranking_matrix[row, col] == 0.5 # objects may or may not be together
                number_conflicting += 1
                # print(row, col)

            elif negative_ranking_matrix[row, col] == positive_ranking_matrix[row, col] == 0: # do nothing
                number_noratings += 1
                # print(row, col)

            elif negative_ranking_matrix[row, col] == 1:
                final_ranking_matrix[row, col] = 0 # objects are placed separately

            elif positive_ranking_matrix[row, col] == 1:
                final_ranking_matrix[row, col] = 1 # objects are grouped together

    print(f'Number of absent ratings: {number_noratings}')
    print(f'Number of conflicting ratings: {number_noratings}')

    return final_ranking_matrix


def main():

    global objcomb2row
    global rules2col

    # Arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-config', help='Config file')
    args = parser.parse_args()

    dateTimeObj = datetime.now()
    timestampStr = dateTimeObj.strftime("%H_%M_%S-%f_%b-%d-%Y")
    datestampStr = dateTimeObj.strftime("%m-%d-%Y")

    current_folder = os.path.abspath(os.path.dirname(__file__)) + "/"

    # Load config
    with open(args.config, 'r') as fh:
        config = yaml.safe_load(fh)

    train_data_folder = config['DATA']['train_data_folder'] # data folder
    val_data_folder = config['DATA']['val_data_folder'] # data folder

    folder_tag = train_data_folder.split('/')[-1] # tag to identify ranking matrix
    assert len(folder_tag) > 1

    # training and testing only on seen objects
    with open(os.path.join(train_data_folder, 
                'rearrange_ai2thor_allrules_seen-objs_train.json'), 'r') as fh:

        train_examples = json.load(fh)

    with open(os.path.join(val_data_folder, 
                'rearrange_ai2thor_allrules_seen-objs_val.json'), 'r') as fh:

        val_examples = json.load(fh)

    folder_tag += '_seen-objs'

    print(f'Folder tag {folder_tag}')
    print(f'Train data folder: {train_data_folder}, Val data folder: {val_data_folder}')

    # loading seen objects
    objects_df = pd.read_csv(config['DATA']['objects_list'])

    objects_seen_df = objects_df[objects_df['Seen/Unseen']=='Seen']
    filtered_objects = list(objects_seen_df['ObjectName'])

    # generating object combinations from list of seen objects
    object_combinations = []

    for i, obj_i in enumerate(filtered_objects):
        for obj_j in filtered_objects[i:]: # allow combinations with self
            # print((obj_i, obj_j))
            # input('line66')
            object_combinations.append((obj_i, obj_j))

    print(f'Number of object combinations: {len(object_combinations)}')

    # save object combinations, removing last comma
    with open(os.path.join(current_folder,
                            f'object_combinations_{folder_tag}.txt'), 'w') \
            as fh:

        for objcomb in object_combinations:
            fh.write('{},{}\n'.format(objcomb[0], objcomb[1]))

    def objcomb2row(obj1, obj2):
        for i, objtup in enumerate(object_combinations):
            if (obj1, obj2) == objtup or (obj2, obj1) == objtup:
                return i
        raise KeyError(f'{obj1}, {obj2} combination does not exist in list')

    rules_list = config['DATA']['rules'].split(',') # list of rules in the dataset
    print(f'rules list: {rules_list}')
    rules2col_dict = dict({rule:i for i, rule in enumerate(rules_list)})
    rules2col = lambda x: rules2col_dict[x]

    final_ranking_matrix_train = generate_ranking_matrix(train_examples, object_combinations, 
                                                            rules_list)
    np.save(os.path.join(current_folder, f'ranking_matrix_train_{folder_tag}.npy'), 
                final_ranking_matrix_train)
    print('Saved training ranking matrix')

    final_ranking_matrix_val = generate_ranking_matrix(val_examples, object_combinations, 
                                                            rules_list)
    np.save(os.path.join(current_folder, f'ranking_matrix_val_{folder_tag}.npy'), 
                final_ranking_matrix_val)
    print('Saved validation ranking matrix')

if __name__ == '__main__':
    main()